# Copyright 2016 AT&T Corp
# All Rights Reserved.
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.

import os

from oslo_config import cfg
from oslo_log import log as logging
from oslo_policy import _checks
from oslo_policy import policy

from margarine.rbac_exceptions import RbacResourceSetupFailed
from tempest import config

CONF = config.CONF
LOG = logging.getLogger(__name__)

DEFAULT_ROLES = set(['admin', 'admin_support', 'admin_viewer',
                     'snapshot_member', 'support_member', 'viewer',
                     '_member_'])

RULES_TO_SKIP = ['default', 'context_is_admin']
TESTED_RULES = []
PARSED_RULES = {}


"""A class for converting policy files into yaml files with roles.

RBAC testing requires that each rule in a policy file be broken up into
the roles that constitute it. This class automates that process.

:param list,tuple policy_files: OpenStack policy files to be parsed and
                                converted into single yaml files.
                                Examples:
                                ["nova", "heat"]

                                ["/etc/nova/policy.json",
                                 "/etc/heat/policy.json"]
:param list,tuple default_roles: The list of RBAC roles being used for testing.
:param string yaml_output_path: A path that includes the output yaml file.
:param string csv_output_path: A path that includes the output csv file.
:param string diff_output_path: Optional path for validating the generated
                                yaml roles against the current rbac yaml roles.
:param bool include_tested_only: Optional param for only included rules that
                                 are currently tested throughout all Tempest
                                 RBAC tests.
"""


class RbacPolicyConverter(object):

    def __init__(self, policy_files):
        global DEFAULT_ROLES

        self.policy_mapping = self._gen_policy_mapping(policy_files)
        self.default_roles = DEFAULT_ROLES
        self.rules = {}

        if self.default_roles and isinstance(self.default_roles,
                                             (list, tuple)):
            self.default_roles = set(self.default_roles)

        for heading, mapping in self.policy_mapping.items():
            self._get_roles_for_each_rule_in_policy_file(heading, mapping)

    def _gen_policy_mapping(self, policy_files):
        """Create a policy mapping containing metadata about the specified rule.

        The mapping keys are generated by searching each policy file for
        conventional OpenStack service names then translating them to match up
        with Tempest naming conventions for each service (i.e. in tempest.api).

        The mapping values include the original file name and a unique set of
        roles found in each policy file.
        """
        # There should really be a better way to do this.
        # Also, why are the names different at all?
        tempest_mapping = {
            'cinder': 'Volume',
            'glance': 'Image',
            'heat': 'Orchestration',
            'ironic': 'Baremetal',
            'keystone': 'Identity',
            'murano': 'Murano',
            'neutron': 'Network',
            'nova': 'Compute',
            'sahara': 'DataProcessing',
            'swift': 'ObjectStorage',
            'telemetry': 'Telemetry',
            'trove': 'Database',
            'zaqar': 'Messaging'
        }

        alternate_path = '/etc/{0}/policy.json'

        policy_mapping = {}
        for policy_file in policy_files:
            if policy_file and not os.path.isfile(policy_file):
                policy_file = alternate_path.format(policy_file)
                if not os.path.isfile(policy_file):
                    raise RbacResourceSetupFailed(
                        'Policy files: {0}, {1} not found.'.format(
                            policy_file, alternate_path.format(policy_file)))
            if not policy_file or not policy_file.endswith('.json'):
                raise RbacResourceSetupFailed(
                    'Policy file: {0} must be a json file'.format(policy_file))
            mapping_val = None
            for key, val in tempest_mapping.items():
                if key in policy_file:
                    mapping_val = val
                    break
            if mapping_val:
                policy_mapping[mapping_val] = {'file': policy_file}
            else:
                policy_mapping[policy_file] = {'file': policy_file}

        return policy_mapping

    def _get_roles_for_each_rule_in_policy_file(self, heading,
                                                policy_mapping):
        global PARSED_RULES
        global TESTED_RULES
        global RULES_TO_SKIP

        rule_to_roles_dict = {}
        file = policy_mapping['file']
        enforcer = self._init_policy_enforcer(file)

        # To avoid including non-policy rules in the output files, rules that
        # are referenced by other rules are omitted. Policy-specific rules
        # should never be referenced by other policy-specific rules.
        base_rules = set()
        for rule_name, rule_checker in enforcer.rules.items():
            if isinstance(rule_checker, _checks.OrCheck):
                for sub_rule in rule_checker.rules:
                    if hasattr(sub_rule, 'match'):
                        base_rules.add(sub_rule.match)
            elif isinstance(rule_checker, _checks.RuleCheck):
                if hasattr(rule_checker, 'match'):
                    base_rules.add(rule_checker.match)

        RULES_TO_SKIP.extend(base_rules)
        generic_check_dict = self._get_generic_check_dict(enforcer.rules)

        for rule_name, rule_checker in enforcer.rules.items():
            PARSED_RULES.setdefault(heading, [])
            PARSED_RULES[heading].append(rule_name)

            if rule_name in RULES_TO_SKIP:
                continue  # Do not include base rules in the yaml file.
            if isinstance(rule_checker, _checks.GenericCheck):
                continue

            # Determine whether each role is contained within the current rule.
            for role in self.default_roles:
                roles = {'roles': [role]}
                roles.update(generic_check_dict)
                is_role_in_rule = rule_checker(
                    generic_check_dict, roles, enforcer)
                if is_role_in_rule:
                    rule_to_roles_dict.setdefault(rule_name, set())
                    rule_to_roles_dict[rule_name].add(role)

        self.rules.setdefault(heading, {})
        self.rules[heading] = rule_to_roles_dict

    def _init_policy_enforcer(self, policy_file):
        def find_file(path):
            realpath = os.path.realpath(path)
            if os.path.isfile(realpath):
                return realpath
            else:
                return None

        CONF = cfg.CONF
        CONF.find_file = find_file

        enforcer = policy.Enforcer(CONF,
                                   policy_file=policy_file,
                                   rules=None,
                                   default_rule=None,
                                   use_conf=True)
        enforcer.load_rules()
        return enforcer

    def _get_generic_check_dict(self, enforcer_rules):
        generic_checks = set()
        for rule_checker in enforcer_rules.values():
            entries = set()
            self._get_generic_check_entries(rule_checker, entries)
            generic_checks |= entries
        return {e: '' for e in generic_checks}

    def _get_generic_check_entries(self, rule_checker, entries):
        if isinstance(rule_checker, _checks.GenericCheck):
            if hasattr(rule_checker, 'match'):
                if rule_checker.match.startswith('%(') and\
                    rule_checker.match.endswith(')s'):
                    entries.add(rule_checker.match[2:-2])
        if hasattr(rule_checker, 'rule'):
            if isinstance(rule_checker.rule, _checks.GenericCheck) and\
                hasattr(rule_checker.rule, 'match'):
                if rule_checker.rule.match.startswith('%(') and\
                    rule_checker.rule.match.endswith(')s'):
                    entries.add(rule_checker.rule.match[2:-2])
        if hasattr(rule_checker, 'rules'):
            for rule in rule_checker.rules:
                self._get_generic_check_entries(rule, entries)

    def _format_list(self, list_):
        return str(list_).replace(',', ' ')

    def _translate_roles_to_ones(self, role_columns, roles):
        row = ''
        for role_col in role_columns:
            if role_col in roles:
                row += '1,'
            else:
                row += ','
        return row
